# Redis Cache Layer

This package provides a cache layer for `domain.Solver` using Redis.

## Features

- **Прозрачное кэширование**: `CachedSolver` implements interface `domain.Solver`
- **Умная генерация ключей**: SHA256 хэш от отсортированных sizes + amount
- **TTL**: Configurable cache TTL (by default 24 hours)
- **Метрики**: Tracking cache hits/misses
- **Безопасность**: Errors are not cached
- **Асинхронная запись**: Cache write does not block response

## Usage

```go
import (
    "github.com/evgenijurbanovskij/re-partners-assignment/internal/infra/redis"
    "github.com/evgenijurbanovskij/re-partners-assignment/internal/usecase"
    "github.com/redis/go-redis/v9"
)

// Create Redis client
client := redis.NewClient(&redis.Options{
    Addr: "localhost:6379",
})

// Create base solver
baseSolver := usecase.NewDPSolver()

// Wrap in cache layer
cachedSolver := redis.NewCachedSolver(baseSolver, client, 24*time.Hour)

// Use as regular solver
solution, err := cachedSolver.Solve(ctx, sizes, amount)
```

## Cache Key Generation

Cache key is generated by formula:
```
key = "solver:" + sha256(sorted_sizes) + ":" + amount
```

This guarantees:
- Consistency: same sizes in different order give one key
- Uniqueness: different tasks have different keys
- Компактность: фиксированная длина независимо от количества sizes

## Метрики

```go
hits, misses := cachedSolver.GetMetrics()
fmt.Printf("Cache hit rate: %.2f%%\n", float64(hits)/(float64(hits+misses))*100)
```

## Testing

Run Redis via docker-compose:
```bash
docker-compose -f deployments/docker-compose.yaml up -d redis
```

Run tests:
```bash
go test -v ./internal/infra/redis/
```

For benchmarks:
```bash
go test -bench=. -benchmem ./internal/infra/redis/
```

## Architectural Decisions

### Why Asynchronous Write?

Cache write happens asynchronously (in goroutine), to not block user response. This means:
- ✅ First call returns quickly
- ✅ Second call already uses cache
- ⚠️ If Redis write fails, user wont know (but this is OK for cache)

### Why Not Cache Errors?

Validation and business logic errors are not cached because:
- They are computed quickly (validation is cheaper than cache)
- May be temporary (e.g., context issues)
- Dont want to cache incorrect state

### TTL 24 hours

Chosen compromise between:
- Data relevance (if algorithm changes)
- Cache efficiency (long enough for reuse)
- Usingм памяти Redis (автоматическая очистка старых записей)

## Производительность

Cache is effective for:
- ✅ Сложных задач (большие amount, много sizes)
- ✅ Repeated requests
- ✅ High load

Cache may be ineffective for:
- ❌ Simple tasks (overhead > benefit)
- ❌ Unique requests (cache miss every time)
- ❌ Low load (Redis overhead)

In production, it is recommended to monitor metrics and adjust TTL based on usage patterns.
